今天突發奇想寫Div.1，好難。  
  
A其實我有想到，只是忘了開long long導致這題卡了我快一個小時。  
對於每個點，因為選中間的值不會大於max(選左邊,選右邊)（運用greedy），所以只需要存選最左邊和最右邊，跟下面的節點的和的最大值。  
  
B排組一樣是把我揍爛，看了[別人的解](https://www.oi-liu.com/2021/05/27/CodeForces-1528B-Kavi-on-Pairing-Duty/)才會，但也不是真的很清楚。（這個網站進去cpu用量就會變超高，要小心）。  
  
C當然也不會，[別人的解在這](https://blog.csdn.net/weixin_44178736/article/details/117258539)，這題超棒的，需要用到[樹壓平](https://slides.com/justinlai2003/deck-51151b#/1)來快速判斷祖孫關係，然後再透過一些巧妙的方法來維護目前的樹鍊，然後就可以dfs了。  
具體方式就是把點的l和index存到pair<int,int>裡，再把pair<int,int>存到set裡，就會按照l排序，然後加一個點（dfs多走一個點）時如果set沒東西就直接加；如果把目前的點放到set中會在set的最前面或最後面，而且與最前面或最後面沒包含關係（祖孫關係）就加；如果排進去會在中間的話，只需要看左右兩個，因為樹壓平的特性，任兩個區間都不會部份相交，所以左邊的第二個區間不包含左邊時不用管他、包含時如果也包含現在的區間那就選左+自己、只包含左邊也不用管他，總之就是可以不用管，右邊同理，所以只需要看左右兩邊。  
然後如果和左右兩邊都沒包含關係就會多一個「貢獻」，與右邊有包含關係時就選右邊，所以不會有貢獻，情況只剩下與左邊有包含關係，但與右邊沒包含關係，這時如果左右沒包含關係才會有貢獻，否則選左右兩個就可以了，不需要選目前的區間（準確來講是在加入左邊節點時就已經貢獻一次了）。這個方法非常巧妙，要頭腦非常清楚才能想得到（至少如果我在賽中應該是想不到）。
